// Examle with index: 
START FROM resource
EXTEND key = CSHARP(`match(resource.subscription, "/subscription/{*}/")`)
USEINDEX SUBSCRIPTION_TO_HEALTH 
FILTER index != null
RETURN resource.id, index.healthId


DEFINE INDEX SUBSCRIPTION_TO_HEALTH
START FROM serviceGroupMember 
EXTEND s = CSHARP(`match(serviceGroupMember.sourceId, "/subscription/{*}/")`), keys = ANCESTORS(serviceGroupMember.targetId)
USEINDEXFORARRAY HEALTH_RESOURCES
CREATE key = s, index


DEFINE INDEX HEALTH_RESOURCES
START FROM healthResource
EXTEND sgid = CSHARP(`match(healthResource.id, "{*}/providers/Microsoft.Health*")`)
CREATE key = sgid, {healthId : healthResource.id}


DEFINE FUNCTION ANCESTORS
PARAMS string
RETURNS string[]


// GET SQL server dependencies 
START FROM resource
FILTER resource.type == "virtualMachine"
WALKTONEIGHBORS :DependencyOf -> neighbor
FILTER neighbor.type == "SQLServer"
RETURN resource.id, neighbor.id


// GET SQL server dependencies and their direct SG ancestors which has health extensions
START FROM resource
FILTER resource.type == "virtualMachine"
WALKTONEIGHBORS :DependencyOf-> neigh                               // fanout to all the affinity nodes 1 
FILTER neigh.type == "SQLServer"                                    // fan back, or better filter inline on the affinitized node via query plan 
WALKTONEIGHBORS :ServiceGroupMember-> sg                            // fanout to all affinity nodes again  2
EXTEND keys = ANCESTORS(sg.id)                                      // Ancestor lookup for an array of IDS 3
USEINDEXFORARRAY HEALTH_RESOURCES                                   // Array lookup for a bunch of ids  4
FILTER index != null                                                // inline filter based on results
RETURN resource.id, index.healthId                                  // Send notification based on return value, total of at least 4 lookups or out of box calls 


START FROM resource
FILTER resource.type == "virtualMachine"
FILTER resource.tags.foo == "bar"
RETURN resource.id, "<fixed sg id>"                                 

START FROM resource
RETURN resource.id resource.rourceGroup

START FROM resourceGroup
RETURN resourceGroup.id resourceGroup.sub



// Examle without an index that doesn't denormalize ancestors: 
// First create the subscription to SG index, which is just SGMs where source is a subscription, we should assume these exist as built-ins probably
DEFINE INDEX SUB_TO_SG_LEAF
START FROM serviceGroupMember 
FILTER ISSUBSCRIPTION(serviceGroupMember.source) == true
CREATE key = serviceGroupMember.source, serviceGroupMember.target

START FROM resource
EXTEND key = CSHARP(`match(resource.subscription, "/subscription/{*}/")`)
USEINDEX SUB_TO_SG_LEAF // index variable will contain an sg id
EXTEND keys = ANCESTORS(index)
USEINDEXFORARRAY HEALTH_RESOURCES
FILTER index != null
RETURN resource.id, index.healthId